# 掛け算としての結合
SQLでは結合が掛け算に相当する(行数についてみれば)
| 販売実績テーブル       |        |         |   | 商品マスタ |           |
|------------------------|--------|---------|---|------------|-----------|
| sale_date              | item_no| quantity|   | item_no    | item      |
| 2018-10-01             | 10     | 4       |   | 10         | SDカード   |
| 2018-10-01             | 20     | 10      |   | 20         | CD-R      |
| 2018-10-01             | 30     | 3       |   | 30         | USBメモリ |
| 2018-10-03             | 10     | 32      |   | 40         | DVD       |
| 2018-10-03             | 30     | 12      |   |            |           |
| 2018-10-04             | 20     | 22      |   |            |           |
| 2018-10-04             | 30     | 7       |   |            |           |

EX) 以下のように商品ごとの総販売数を求める
|item_no|total_qty|
|:----|:----|
|10|36|
|20|32|
|30|22|
|40|NULL|


``` sql
SELECT
	i.item_no
	,s.total_qty
FROM
	Chapter8Items AS i
LEFT JOIN
	(SELECT
		item_no
		,SUM(quantity) AS total_qty
	 FROM
		Chapter8SalesHistory
	 GROUP BY
		item_no) AS s
ON
	i.item_no = s.item_no
```
上記は結合する前に売上テーブルの商品番号を集約して  
item_noを主キーとする中間ビューを作ってから外部結合している  
**→両テーブルitem_noを主キーとする一対一の関係となる**  
ただし、上記のような中間ビューはデータを一度メモリに保持する必要があるに加え  
売上履歴テーブルには主キーのインデックスがないため結合条件で利用できずパフォーマンスが良くない  

よって結合を掛け算としてみる観点を導入する  
商品マスタと売上履歴テーブルはitem_noをキーとする1対Nの関係にある  
-> **結合において片方が1なら結合後の行数は増えない = 1に何を掛けても増えないのと同じ**  
といった視点を入れたSQL
``` sql
SELECT
	i.item_no
	,SUM(s.quantity) AS total_qty
FROM
	Chapter8Items as i
LEFT JOIN
	Chapter8SalesHistory as s
ON
	i.item_no = s.item_no
GROUP BY
	i.item_no
```
コードが簡潔になり、中間ビューがないことによってパフォーマンスが向上する  
※N:Nの関係では使えないため、どちらかを集約して1:Nの関係にする必要がある
