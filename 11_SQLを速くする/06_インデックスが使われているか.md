# そのインデックスは本当に使われているか
サイズの大きなオブジェクトよりサイズの小さなポインタを検索した方が効率が良い  
→ 書籍の索引ページのイメージ  
最もポピュラーなBツリーインデックスでは2分探索による高速検索が可能なよう工夫されている  

以下のSQLはインデックスを使うつもりだが、テーブル全件を検索している
``` sql
SELECT * FROM SomeTable
WHERE
	100 < col_1 * 1.1
```
col_1という索引列に加工を行っているため、インデックスが使えていない  
SQLは計算向きの言語ではないし、DBのエンジンは上記程度でも式変形してくれないことも多い  
よって以下のように条件を使えばOK
``` SQL
SELECT * FROM SomeTable
WHERE
	100 / 1.1 < col_1
```
同様に索引列に関数を適用しているケースでもインデックスは利用されない
``` sql
SELECT * FROM SomeTable
WHERE
	SUBSTRING(col_1,1,1) = 'a'
```
要は**インデックスを利用するときは、列は裸**がインデックス周りのチューニングの基本

### インデックス列にNULLが存在する
インデックスにおけるNULLの扱いは難しく、実装によっても異なる  
IS NULLやIS NOT NULLを使用するとインデックスが利用されなかったり  
NULLが多い列ではインデックスが利用されなかったりという制限を受けることがある
``` sql
SELECT * FROM SomeTable
WHERE
	col_1 IS NULL
```
インデックスにおいてNULLが難しい問題になる理由は**原則的にNULLが列の正当な値ではないから**  
そのため、どう扱うかに関して統一的な基準がなく、状況が複雑になっている  
どうしてもIS NOT NULLと同等の条件でインデックスを利用したいなら以下の方法がある  
※ 最小値が1の前提
``` sql
SELECT * FROM SomeTable
WHERE
	0 < col_1
```
上記はcol_1すべての値が選択され、col_1 = NULLがunknownと評価され選択されない  
ただ、「NULLでない行」を選択するならそのように書くのが正しいコーディングスタイルであり  
0 < col_1はコードの意味を混乱させるため、応急処置程度に使うにとどめたほうがいい

### 否定形を使っている
次のような否定形はインデックスを利用できない
- <>
- !=
- NOT IN
``` sql
SELECT * FROM SomeTable
WHERE
	col_1 <> 100
```

### ORを使っている
col_1とcol_2に別々の索引がある場合、または(col_1,col_2)に複合索引を張っている場合のいずれも  
OR条件で結合するとインデックスが利用できなくなるか、使えたとしてもANDと比べると非効率的な検索になる
``` sql
SELECT * FROM SomeTable
WHERE
	100 < col_1
OR
	col2 = 'abc'
```
どうしてもOR条件を使用した場合はビットマップインデックスがあるが、更新がコストが高くなるデメリットがある  
オンラインの更新処理が少ないBI/DWH向けとされていて、使いどころは限定的

### 複合索引の場合、列の順番を間違えている
(col_1,col_2,col_3)に対してこの順番で複合インデックスが張られているとする  
この場合、作成されたインデックスの列の順番が重要となる
``` sql
-- OK-1
SELECT * FROM SomeTable
WHERE
	col_1 = 10
AND
	col2 = 100
AND
	col_3 = 500

-- OK-2
SELECT * FROM SomeTable
WHERE
	col_1 = 10
AND
	col2 = 100

-- NG-1
SELECT * FROM SomeTable
WHERE
	col_1 = 10
AND
	col_3 = 500

-- NG-2
SELECT * FROM SomeTable
WHERE
	col_2 = 100
AND
	col_3 = 500
```
**必ず最初の列(col_1)を先頭に書かなければいかないに加え、順番を崩してもいけない**  
順番が崩れていてもインデックスが利用できるDBもあるが、正しい順番の場合よりパフォーマンスは落ちる  
-> このルールが守れないなら、別々のインデックスに分割することを検討する

### 後方一致または中間一致のLIKE述語を用いている
LIKE述語を使う時は前方一致検索のみ索引が利用される
``` sql
-- OK
SELECT * FROM SomeTable WHERE col_1 LIKE 'a%'
-- NG-1
SELECT * FROM SomeTable WHERE col_1 LIKE '%a'
-- NG-2
SELECT * FROM SomeTable WHERE col_1 LIKE '%a%'
```

### 暗黙の型変換を行っている
文字列型で定義されたcol_1に対する条件を書く場合の例
``` sql
-- OK-1
SELECT * FROM SomeTable WHERE col_1 = '10'
-- OK-2
SELECT * FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2))
-- NG
SELECT * FROM SomeTable WHERE col_1 = 10
```
暗黙の型変換は*オーバーヘッドを発生させるに加え、インデックスまで使用不可になる  
※ コンピューターが本来の処理を行うために、付随して発生する間接的な負荷や処理時間  
そのため、エラーにならなくとも明示的な型変換を心がける(変換は列でなく、条件値のほうでする)  
