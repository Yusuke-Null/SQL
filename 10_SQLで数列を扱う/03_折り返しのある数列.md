# 折り返しのある数列
|seat|line_id|status|
|:----|:----|:----|
|1|A|占|
|2|A|占|
|3|A|空|
|4|A|空|
|5|A|空|
|6|B|占|
|7|B|占|
|8|B|空|
|9|B|空|
|10|B|空|
|11|C|空|
|12|C|空|
|13|C|空|
|14|C|占|
|15|C|空|

Q. 1~15の座席から3人で連続した席が予約できるかを求める  
{9,10,11}は列が折り返されているため、選択してはいけない  
- NOT EXISTS
``` sql
DECLARE @head_cnt int = 3;
SELECT
	s1.seat AS 'start_seat'
	,'~'
	,s2.seat AS 'end_seat'
FROM
	Chapter10Seats2 AS s1
CROSS JOIN
	Chapter10Seats2 AS s2
WHERE
	s2.seat = s1.seat + (@head_cnt - 1)
AND
	NOT EXISTS(
		SELECT * FROM Chapter10Seats2 AS s3
		WHERE
			s1.seat <= s3.seat
		AND
			s3.seat <= s2.seat
		AND
			(s3.status <> '空'
		OR
			 s1.line_id <> s3.line_id)
	)

-- result
start_seat	(列名なし)	end_seat
3	~	5
8	~	10
11	~	13
```
上記のステップは以下である
1. 自己結合で始点と終点の組み合わせを作る  
s2.seat = s1.seat + (@head_cnt - 1)
始点と終点の大きさが3以外の組み合わせを排除する
2. 始点と終点の全ての点が満たすべき条件を記述
始点と終点の間を移動する点集合(s3)を追加し、移動範囲の条件を指定する  
> s1.seat <= s3.seat AND s3.seat <= s2.seat)
3. 全ての行の座席が「空」であること = 「占」でない行が存在しない
ラインIDが同じであること = ラインが同じでない行が存在しない
> status = '占' または status <> '空'  
> OR s1.line_id <> s3.line_id

- HAVING
``` sql
DECLARE @head_cnt int = 3;
SELECT
	s1.seat AS 'start_seat'
	,'~'
	,s2.seat AS 'end_seat'
FROM
	Chapter10Seats2 AS s1
CROSS JOIN
	Chapter10Seats2 AS s2
CROSS JOIN
	Chapter10Seats2 AS s3
WHERE
	s2.seat = s1.seat + (@head_cnt - 1)
AND
	s1.seat <= s3.seat
AND
	s3.seat <= s2.seat
GROUP BY
	s1.seat
	,s2.seat
HAVING
	COUNT(*) = SUM(
		CASE
			WHEN s3.status = '空'
			AND s1.line_id = s3.line_id THEN 1
			ELSE 0
		END)
```

- ウィンドウ関数
``` sql
DECLARE @head_cnt int = 3;
SELECT
	seat AS 'start_seat'
	,'~'
	,seat + (@head_cnt - 1) AS end_seat_no
FROM
	(SELECT
		seat
		,MAX(seat) OVER(
			PARTITION BY line_id
			ORDER BY seat
			ROWS BETWEEN 2 FOLLOWING AND 2 FOLLOWING) AS end_seat
	 FROM
		Chapter10Seats2
	 WHERE
		status = '空'
	) AS tmp
WHERE
	end_seat - seat = (@head_cnt - 1)
```
上記のステップは以下である  
1. ステータスが空のレコードを以下のようにする
	- line_idごとの部分集合を作る
 	- seat順に並べて2行後の始点seatと終点のseatを取得する
2. サブクエリ内の終点と始点のseatの差が2であるレコードという条件を付ける  
