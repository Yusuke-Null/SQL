# 効率の良い検索を利用する
SQL単体がレスポンスが遅い原因とは限らない  
本格的なパフォーマンスチューニングには使用しているハードウェア、DBMSの機能や特徴の知識が必要  
メモリの配分が悪い、ストレージ構成が不適切なシステムの物理的な設計そのものに起因することもある  
また、SQLに起因する性能問題の解決にもDBMSが選択する実行計画を見て判断することが求められる  
本章で紹介する方法も万能薬ではない。加えて、実装非依存でSQLを見直す方法をまとめた。

DBMSが立てる実行計画はかなりの程度コードの外的な構造に左右される

### サブクエリを引数に取る場合、INよりもEXISTSを使う
IN述語はパフォーマンス面からみるとボトルネックになる危険を抱えている  
そのため、INを見直すだけで劇的にパフォーマンス改善が望めることもある  
IN(1,2,3)のような値を取る場合はそれほど気にしなくもよいが、サブクエリを引数に取る場合は注意が必要  
**NOT INとNOT EXISTSは大抵全く等しい結果を返すが、サブクエリを使う場合はEXISTSの方が速い**  
Chapter8のClass_A,Class_B
| Class_A |       |   | Class_B |       |
|--------|--------|---|--------|--------|
| id     | name   |   | id     | name   |
| 1      | 田中   |   | 1      | 田中   |
| 2      | 鈴木   |   | 2      | 鈴木   |
| 3      | 伊集院 |   | 4      | 西園寺 |

以下のSQLは同じ結果を返すが、EXISTSのほうが速く動作する可能性がある
``` sql
-- IN述語
SELECT * FROM Chapter8Class_A
WHERE
	id IN(SELECT id FROM Chapter8Class_B);

-- EXISTS
SELECT * FROM Chapter8Class_A AS a
WHERE
	EXISTS(
		SELECT id FROM Chapter8Class_B AS b
		WHERE
			a.id = b.id)

-- result
id	name
1	田中
2	鈴木
```
EXISTSの方が速い理由は以下
1. 結合キーにインデックスが張られていれば、Bテーブルの実表は見に行かずインデックス参照で済む
2. EXISTSは１行でも条件に合致する行を見つけたら検索を打ち切る一方、INは全表検索する(NOTも同様)

INの引数にサブクエリを当てる場合、DBはまずサブクエリを実行し、その結果を一時的なワークテーブル(インラインビュー)に格納し  
その後、ビューを全件走査する。多くの場合、非常にコストがかかるに加え、一般にワークテーブルにはインデックスが存在しない  
EXISTSならワークテーブルは作成されないため速いが、可動性は劣る  
→ INで応答時間に問題ないならわざわざ書き換える必要はない。  
  最近のDBMSはINでもパフォーマンスがあがるよう改善を図るようになっている  

### サブクエリを引数に取る場合、INよりも結合を使う
前述のSQLを結合で書き換えると以下になる
``` sql
SELECT * FROM Chapter8Class_A AS a
INNER JOIN
	Chapter8Class_B AS b
ON
	a.id = b.id
```
結合なら少なくともどちらかのid列のインデックスが利用できるに加え  
サブクエリもないため中間テーブルも作られない。  
インデックスがない場合はEXISTSの方が速い可能性がある
