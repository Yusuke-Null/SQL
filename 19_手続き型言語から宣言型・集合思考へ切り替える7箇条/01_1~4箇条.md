# はじめに
SQLの考え方を習得する最大の障壁は手続き型言語の考え方である  
-> 代入、分岐、ループを基本的な処理単位として、システム全体をこの基本的な処理へ分割する発想  
SQLの考え方はある意味対極にある  
-> 代入やループなどの手続きは一切なく、データもレコードでなく、もっと複合的な集合単位で扱われる  
そのため、無理に手続き的に組もうとすると長大で複雑なSQLになるか、安易にプロシージャとカーソルに手を出して  
手続き型の世界へ戻ることになる。ウィンドウ関数の登場にってSQLでも手続き型の考え方が輸入されつつも  
ベースには宣言型・集合指向的な考え方があることに変わりはない  
よって、SQLの習熟にはSQLとRDBの世界を支配する独自の原理を理解し、使いこなさなければならない  


## 1.IF文やCASE文はCASE式に置き換える
手続き型言語では処理の分岐は「文」の単位で行うが、SQLでは文中の「式」の単位で分岐させる  
SQLでも1つのSELECTやUPDATE文の中で手続き型言語と同様の複雑で柔軟な分岐を表現することは可能だが  
その為に威力を発揮するのがCASE式である  
CASE「文」でなく、CASE「式」であるため、実行時には1つの値に評価される  
そのため、定数や1+1が書ける場所ならどこにも書くことができ、1つの値に定まることから  
他の式や関数を引数に取ることができる  
**また、入力に対して1つの値を返す点ではCASE式は一種の関数である**  
条件を入れ子にできるため、階層型な分岐もできる点が関数型の言語と同じ
``` Lisp
-- Lispとは関数型言語
cond(
  ((= x 1) 'xは1です')
    ((= x 2) 'xは2です')
      (t 'xは1です'))
```
``` sql
CASE WHEN x = 1 THEN 'xは1です'
  WHEN x = 2 THEN 'xは2です'
  ELSE 'xはそれ以外です'
END
```

## 2.ループはGROUP BY句やウィンドウ関数で置き換える
SQLには文単位でのループも存在しない  
カーソルでできなくもないが、手続き型の世界で、ピュアSQLとは無関係  
手続き型言語でループが利用される定番の処理に「コントロールブレイク」がある  
これをSQLではGROUP BY句と相関サブクエリで表現できる  
GROUP BY句で集約すれば済むものをヒラでSELECTした結果を1行ずつカーソルでループさせて集約を行う事例があるが  
これはRDBをただのファイル、SQLを1行ずつレコードを呼び出すインターフェースに最小化した手続き型言語の考えで  
全ての問題に対処しようとする態度である  
**SQLにはループはないが、なくても困ることはない**

## 3.テーブルの行に順序はない
テーブルをファイルとみなす最大の危険は行が順序を持つと誤解してしまうこと  
ファイルにとっては行順がばらばらに表示されることがあれば使い物にならないから行の順序は大切だが  
RDBにおいて、テーブルを読み出しときはまさにそういう事態が生じる  
INSERTされた順に読みだされる保証はないし、SQLでのデータ操作においてもその必要はない  
RDBのテーブルは集合の1種で、行の順序という目に見える概念を切り捨て、抽象度を高めるために考えられた概念である  
テーブルとはデータが順序良く整理されたバインダーではなく、雑多に色々放り込まれたバッグのイメージに近い  
順序に頼った発想だと、ビューにORDER BY句を指定したりと、無駄に複雑で移植性のないコードが生み出される

## 4.テーブルを集合と見なそう
テーブルはファイルよりもずっと抽象度の高い存在である  
ファイルはその記憶方法に緊密に結び付けられているが  
SQLでテーブルやビューを使う時はそのメモリ上での扱いを一切気にする必要がない(パフォーマンスを除く)  
テーブルとファイルを同じと見なしてしまいがちだが、1テーブルが1つのファイルに対応しているわけでもなければ  
ファイルのように1行ずつ読みだされるわけではない  
自己結合すると上記の理解ができる  
-> SQLで同じテーブルに別名をつけてあたかも別のテーブルとして存在しているかのように扱えるから
