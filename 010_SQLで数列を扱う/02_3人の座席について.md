# 3人の座席について
|seat|status|
|:----|:----|
|1|占|
|2|占|
|3|空|
|4|空|
|5|空|
|6|占|
|7|空|
|8|空|
|9|空|
|10|空|
|11|空|
|12|占|
|13|占|
|14|空|
|15|空|

Q. 1~15の座席から3人で連続した席が予約できるかを求める  
※ {7,8,9}や{8,9,10}を区別すること  
- NOT EXISTS
``` sql
DECLARE @head_cnt INT = 3;
SELECT
	s1.seat AS 'start_seat'
	,'~'
	,s2.seat AS 'end_seat'
FROM
	Chapter10Seats AS s1
CROSS JOIN
	Chapter10Seats AS s2
WHERE
	s2.seat = s1.seat + (@head_cnt - 1)
AND
	NOT EXISTS(
		SELECT * FROM
			Chapter10Seats AS s3
		WHERE
			status = '占'
		AND
			s1.seat <= s3.seat
		AND
			s3.seat <= s2.seat)

-- result
start_seat	(列名なし)	end_seat
3	~	5
7	~	9
8	~	10
9	~	11
```
上記のステップは以下である
1. 自己結合で始点と終点の組み合わせを作る  
s2.seat = s1.seat + (@head_cnt - 1)
始点と終点の大きさが3以外の組み合わせを排除する
2. 始点と終点の全ての点が満たすべき条件を記述
始点と終点の間を移動する点集合(s3)を追加し、移動範囲の条件を指定する  
> s1.seat <= s3.seat AND s3.seat <= s2.seat)
3. 全ての行の座席が「空」であること = 「占」でない行が存在しない
> status = '占' または status <> '空'

- ウィンドウ関数
``` sql
DECLARE @head_cnt INT = 3;
SELECT
	seat
	,'~'
	,seat + (@head_cnt - 1)
FROM
	(SELECT
		seat
		,MAX(seat) OVER(
			ORDER BY seat
			ROWS BETWEEN 2 FOLLOWING AND 2 FOLLOWING
		) AS end_seat
	 FROM
		Chapter10Seats
	 WHERE
		status = '空') tmp
WHERE
	end_seat - seat = (@head_cnt - 1);

-- result
seat	(列名なし)	seat_plas_headcnt
3	~	5
7	~	9
8	~	10
9	~	11
```
上記のステップは以下である  
1. ステータスが空のレコードをseat順に並べて2行後の始点seatと終点のseatを取得する
2. サブクエリ内の終点と始点のseatの差が2であるレコードという条件を付ける  
ウィンドウ関数は順序という従来のSQLが禁足した概念が使えるため  
数列のようなもともと順序を持った構造を扱う際に大きなメリットがある  
(NOT EXISTSの方がパフォーマンスが優れる可能性もある)
