# 連番を作る
関係モデルのデータ構造には順序の概念がないため、RDBのテーブルやビューにも行列の順序はない  
SQLも順序集合を扱うことが直接的な目的ではなかった  
-> ウィンドウ関数の登場で順序を持つデータの取り扱いが非常にスムーズになった

## 連番の作り方
実装ではシーケンスが振られており、その番号を使ったり、RDBのバージョンによってはWITH句を使ったりすることで  
連番を取ることができるが、実装やバージョンに非依存の形で連番を作る
Q. 1つのSQLで00~99の中には0,1,2...の各数字は何個ずつ含まれているか  
A. 各20個 -> 10の位で使われているものと1の位で使われているもの21個 - 1個(重複分)  
Ex)(10,11,12...) + (01,11,21...) - (重複している11)  
→ ある数を文字としてみた場合、それは各位を構成する数字を組み合わせて作られる集合である  

Q. 0~99までの連番を作る  
|digit|
|:----|
|0|
|1|
|2|
|3|
|4|
|5|
|6|
|7|
|8|
|9|

先ほどの例の通り、0~9の組み合わせでどんな巨大な数字も作れる  
すると、2つのDigits集合の直積を取ることで作れる
``` sql
SELECT d1.digit + (d2.digit*10) AS seq
FROM
	Chapter10Digits AS d1
CROSS JOIN
	Chapter10Digits AS d2
ORDER BY
	seq
```
Q. 1~542の連番を求める  
WHEREで条件を指定すればよい
``` sql
SELECT d1.digit + (d2.digit*10) + (d3.digit*100) AS seq
FROM
	Chapter10Digits AS d1
CROSS JOIN
	Chapter10Digits AS d2
CROSS JOIN
	Chapter10Digits AS d3
WHERE
	0 < d1.digit + (d2.digit*10) + (d3.digit*100)
AND
	d1.digit + (d2.digit*10) + (d3.digit*100) <= 542
ORDER BY
	seq
```
上記のような数を数字の組み合わせであるというアプローチは数の順序という性質を無視している

## 欠番を求める
|seq|
|:----|
|1|
|2|
|4|
|5|
|6|
|7|
|8|
|11|
|12|

ビューを作成
``` sql
CREATE VIEW Chapter10Sequence(seq) AS
SELECT
	d1.digit + (d2.digit*10) + (d3.digit*100) 
FROM
	Chapter10Digits AS d1
CROSS JOIN
	Chapter10Digits AS d2
CROSS JOIN
	Chapter10Digits AS d3
```

Q. 欠番を全て求める  
Diditsのビュー(Chapter10Sequence)から0~nの歯抜けのない自然数を取得できるため  
SQLでSeqTbl集合との差集合を求めればよい  
- EXCEPT
``` sql
SELECT seq FROM Chapter10Sequence
WHERE
	0 < seq
AND
	seq < 12
EXCEPT
	SELECT
		seq 
	FROM
		Chapter10SeqTbl

-- result
seq
3
9
10
```
- NOT IN
``` sql
SELECT seq FROM Chapter10Sequence
WHERE
	0 < seq
AND
	seq < 12
AND
	seq NOT IN(
		 SELECT
			 seq 
		 FROM
			 Chapter10SeqTbl)
```
- NOT EXISTS
``` sql
SELECT seq FROM Chapter10Sequence AS s1
WHERE
	0 < seq 
AND
	seq < 13
AND
	NOT EXISTS(
		SELECT * FROM Chapter10SeqTbl AS s2
		WHERE
			s1.seq = s2.seq)
ORDER BY
	seq
```
- 外部結合
``` sql
SELECT s1.seq FROM Chapter10Sequence AS s1
LEFT JOIN
	Chapter10SeqTbl AS s2
ON
	s1.seq = s2.seq
WHERE
	s2.seq IS NULL
AND
	0 < s1.seq
AND
	s1.seq < 13
ORDER BY
	s1.seq
```
可動性については下記の順の通り  
1. EXCEPT
2. NOT IN
3. NOT EXISTS
4. 外部結合

ただ、パフォーマンスならソートが不要でseqのインデックスが使えそうなNOT EXISTSが期待できる  
EXCEPTは2つのテーブルスキャンとソートが発生してしまう(ALLが使えればソートはしないが)  
NOT INは一度ビューを作るため、パフォーマンスはかなり劣るに加え、NULLが含まれていると結果がおかしくなる  
外部結合はソートが不要で結合条件でseqのインデックスを使うことができるため、NOT EXISTSに匹敵する速さ

-- EXCEPT 条件を能動的に  
実行コストは高くなるが、より一般化できる  
非相関サブクエリであるため1度しか実行しない + seqにインデックスがあれば極値関数を高速化できる
``` sql
SELECT seq FROM Chapter10Sequence
WHERE
	(SELECT MIN(seq) FROM Chapter10SeqTbl) <= seq
AND
	seq <= (SELECT MAX(seq) FROM Chapter10SeqTbl)
EXCEPT
	SELECT
		seq 
	FROM
		Chapter10SeqTbl
```
